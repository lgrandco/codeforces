{"name":"maximum-path-score-in-a-grid","url":"https://leetcode.com/contest/weekly-contest-475/problems/maximum-path-score-in-a-grid/","tests":[{"id":1763864947264,"input":"2\n2\n2\n0 1\n2\n2 0\n1\n2\n2\n0 1\n2\n1 2\n1\n","output":" "}],"interactive":false,"memoryLimit":256,"timeLimit":2000,"group":"LeetCode","parsedCode":"from typing import *\nimport collections\nfrom collections import deque, defaultdict, Counter, OrderedDict\nimport random\nimport heapq\nimport bisect\nimport itertools\nfrom functools import lru_cache, reduce\nfrom math import inf, gcd, lcm, sqrt, ceil, floor, log, log2, log10\nimport re\nimport string\n\n# Global input buffer for single word reading\nclass InputBuffer:\n    def __init__(self):\n        self.buffer = []\n        self.index = 0\n    \n    def next_word(self):\n        while self.index >= len(self.buffer):\n            try:\n                line = input().strip()\n                if line:\n                    self.buffer = line.split()\n                    self.index = 0\n                else:\n                    continue\n            except EOFError:\n                return None\n        \n        word = self.buffer[self.index]\n        self.index += 1\n        return word\n    \n    def next_line(self):\n        self.buffer = []\n        self.index = 0\n        try:\n            return input().strip()\n        except EOFError:\n            return None\n\n_input_buffer = InputBuffer()\n\n# Definition for singly-linked list\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Definition for binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass IO:\n    class Input:\n        @staticmethod\n        def read_bool() -> bool:\n            word = _input_buffer.next_word()\n            return word.lower() in ['true'] if word else False\n        \n        @staticmethod\n        def read_int() -> int:\n            word = _input_buffer.next_word()\n            return int(word) if word else 0\n        \n        @staticmethod\n        def read_float() -> float:\n            word = _input_buffer.next_word()\n            return float(word) if word else 0.0\n        \n        @staticmethod\n        def read_string() -> str:\n            return _input_buffer.next_line()\n        \n        @staticmethod\n        def read_char() -> str:\n            word = _input_buffer.next_word()\n            return word[0] if word else ''\n        \n        @staticmethod\n        def consume_newline() -> None:\n            _input_buffer.next_line()\n        \n        # Array functions\n        @staticmethod\n        def read_int_array() -> List[int]:\n            n = IO.Input.read_int()  \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_int() for _ in range(n)] \n        \n        @staticmethod\n        def read_float_array() -> List[float]:\n            n = IO.Input.read_int()  \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_float() for _ in range(n)]  \n        \n        @staticmethod\n        def read_string_array() -> List[str]:\n            n = IO.Input.read_int() \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_string() for _ in range(n)]  \n        \n        @staticmethod\n        def read_char_array() -> List[str]:\n            n = IO.Input.read_int() \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_char() for _ in range(n)]  \n        \n        # 2D Array functions\n        @staticmethod\n        def read_int_2d_array() -> List[List[int]]:\n            m = IO.Input.read_int()  \n            if m == 0:\n                IO.Input.consume_newline()\n            result = []\n            for _ in range(m):\n                row = IO.Input.read_int_array()\n                result.append(row)\n            return result\n        \n        @staticmethod\n        def read_char_2d_array() -> List[List[str]]:\n            m = IO.Input.read_int() \n            if m == 0:\n                IO.Input.consume_newline()\n            result = []\n            for _ in range(m):\n                row = IO.Input.read_char_array()\n                result.append(row)\n            return result\n        \n        # Linked List\n        @staticmethod\n        def read_list_node() -> Optional[ListNode]:\n            n = IO.Input.read_int()\n            if n == 0:\n                return None\n            \n            values = [IO.Input.read_int() for _ in range(n)]\n            if not values:\n                return None\n                \n            head = ListNode(values[0])\n            current = head\n            for i in range(1, len(values)):\n                current.next = ListNode(values[i])\n                current = current.next\n            return head\n        \n        # Binary Tree (level-order traversal format)\n        @staticmethod\n        def read_tree_node() -> Optional[TreeNode]:\n            n = IO.Input.read_int()\n            if n == 0:\n                return None\n                \n            values = []\n            for _ in range(n):\n                word = _input_buffer.next_word()\n                if word and word.lower() == 'null':\n                    values.append(None)\n                else:\n                    values.append(int(word) if word else 0)\n            \n            if not values or values[0] is None:\n                return None\n            \n            root = TreeNode(values[0])\n            queue = deque([root])\n            i = 1\n            \n            while queue and i < len(values):\n                node = queue.popleft()\n                \n                if i < len(values):\n                    if values[i] is not None:\n                        node.left = TreeNode(values[i])\n                        queue.append(node.left)\n                    i += 1\n                \n                if i < len(values):\n                    if values[i] is not None:\n                        node.right = TreeNode(values[i])\n                        queue.append(node.right)\n                    i += 1\n            \n            return root\n        \n    class Output:\n        @staticmethod\n        def write_bool(x: bool) -> None:\n            print(\"true\" if x else \"false\", end=\"\")\n        \n        @staticmethod\n        def write_int(x: int) -> None:\n            print(x, end=\"\")\n        \n        @staticmethod\n        def write_float(x: float) -> None:\n            print(x, end=\"\")\n        \n        @staticmethod\n        def write_string(x: str) -> None:\n            print(f'\"{x}\"', end=\"\")\n        \n        @staticmethod\n        def write_char(x: str) -> None:\n            print(f'\"{x}\"', end=\"\")\n        \n        # Array functions\n        @staticmethod\n        def write_int_array(arr: List[int]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(val, end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_float_array(arr: List[float]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(val, end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_string_array(arr: List[str]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(f'\"{val}\"', end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_char_array(arr: List[str]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(f'\"{val}\"', end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        # 2D Array functions\n        @staticmethod\n        def write_int_2d_array(arr: List[List[int]]) -> None:\n            print(\"[\", end=\"\")\n            for i, row in enumerate(arr):\n                IO.Output.write_int_array(row)\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_char_2d_array(arr: List[List[str]]) -> None:\n            print(\"[\", end=\"\")\n            for i, row in enumerate(arr):\n                IO.Output.write_char_array(row)\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        # Linked List\n        @staticmethod\n        def write_list_node(head: Optional[ListNode]) -> None:\n            print(\"[\", end=\"\")\n            first = True\n            current = head\n            while current:\n                if not first:\n                    print(\",\", end=\"\")\n                first = False\n                print(current.val, end=\"\")\n                current = current.next\n            print(\"]\", end=\"\")\n        \n        # Binary Tree (level-order output)\n        @staticmethod\n        def write_tree_node(root: Optional[TreeNode]) -> None:\n            if not root:\n                print(\"[]\", end=\"\")\n                return\n            \n            print(\"[\", end=\"\")\n            queue = deque([root])\n            first = True\n            \n            while queue:\n                level_size = len(queue)\n                has_next_level = False\n                \n                for _ in range(level_size):\n                    node = queue.popleft()\n                    \n                    if not first:\n                        print(\", \", end=\"\")\n                    first = False\n                    \n                    if node:\n                        print(node.val, end=\"\")\n                        queue.append(node.left)\n                        queue.append(node.right)\n                        if node.left or node.right:\n                            has_next_level = True\n                    else:\n                        print(\"null\", end=\"\")\n                \n                if not has_next_level:\n                    break\n            \n            print(\"]\", end=\"\")\n        \n        # List of TreeNodes\n        @staticmethod\n        def write_tree_node_array(arr: List[Optional[TreeNode]]) -> None:\n            print(\"[\", end=\"\")\n            for i, tree in enumerate(arr):\n                IO.Output.write_tree_node(tree)\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n    \n    # Convenience wrapper functions\n    @staticmethod\n    def output(x) -> None:\n        if x is None:\n            print(\"null\", end=\"\")\n        elif isinstance(x, bool):\n            IO.Output.write_bool(x)\n        elif isinstance(x, int):\n            IO.Output.write_int(x)\n        elif isinstance(x, float):\n            IO.Output.write_float(x)\n        elif isinstance(x, str) and len(x) == 1:\n            IO.Output.write_char(x)\n        elif isinstance(x, str):\n            IO.Output.write_string(x)\n        elif isinstance(x, list):\n            if x and isinstance(x[0], list):\n                # 2D array\n                if x[0] and isinstance(x[0][0], int):\n                    IO.Output.write_int_2d_array(x)\n                elif x[0] and isinstance(x[0][0], str):\n                    IO.Output.write_char_2d_array(x)\n                else:\n                    print(x, end=\"\")\n            elif x and isinstance(x[0], int):\n                IO.Output.write_int_array(x)\n            elif x and isinstance(x[0], float):\n                IO.Output.write_float_array(x)\n            elif x and isinstance(x[0], str):\n                if all(len(s) == 1 for s in x):\n                    IO.Output.write_char_array(x)\n                else:\n                    IO.Output.write_string_array(x)\n            elif x and isinstance(x[0], TreeNode):\n                IO.Output.write_tree_node_array(x)\n            else:\n                print(x, end=\"\")\n        elif isinstance(x, ListNode):\n            IO.Output.write_list_node(x)\n        elif isinstance(x, TreeNode):\n            IO.Output.write_tree_node(x)\n        else:\n            print(x, end=\"\")\n\nclass FenwickTree:\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | (i + 1)\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        \"\"\"updates bit[idx] += x\"\"\"\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        \"\"\"calc sum(bit[:end])\"\"\"\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return idx + 1, k\n\n\nget = input\n\n\nclass SortedList:\n    block_size = 700\n\n    def __init__(self, iterable=()):\n        iterable = sorted(iterable)\n        self.micros = [\n            iterable[i : i + self.block_size - 1]\n            for i in range(0, len(iterable), self.block_size - 1)\n        ] or [[]]\n        self.macro = [i[0] for i in self.micros[1:]]\n        self.micro_size = [len(i) for i in self.micros]\n        self.fenwick = FenwickTree(self.micro_size)\n        self.size = len(iterable)\n\n    def add(self, x):\n        i = bisect_left(self.macro, x)\n        j = bisect_right(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= self.block_size:\n            self.micros[i : i + 1] = (\n                self.micros[i][: self.block_size >> 1],\n                self.micros[i][self.block_size >> 1 :],\n            )\n            self.micro_size[i : i + 1] = (\n                self.block_size >> 1,\n                self.block_size >> 1,\n            )\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=-1):\n        i, j = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        i, j = self._find_kth(k)\n        return self.micros[i][j]\n\n    def count(self, x):\n        return self.bisect_right(x) - self.bisect_left(x)\n\n    def __contains__(self, x):\n        return self.count(x) > 0\n\n    def bisect_left(self, x):\n        i = bisect_left(self.macro, x)\n        return self.fenwick(i) + bisect_left(self.micros[i], x)\n\n    def bisect_right(self, x):\n        i = bisect_right(self.macro, x)\n        return self.fenwick(i) + bisect_right(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __repr__(self):\n        return self.__class__.__name__ + (\n            \"({})\".format(self.value) if self else \"()\"\n        )\n\n\nclass LinkedList:\n    def __init__(self, iterable=None):\n        self.sentinel = Node(None)\n        self.sentinel.next = self.sentinel\n        self.sentinel.prev = self.sentinel\n        self.__len = 0\n        if iterable is not None:\n            self += iterable\n\n    def get_node(self, index):\n        node = self.sentinel\n        i = 0\n        while i <= index:\n            node = node.next\n            if node == self.sentinel:\n                break\n            i += 1\n        if node == self.sentinel:\n            node = None\n        return node\n\n    def __getitem__(self, index):\n        node = self.get_node(index)\n        return node.value\n\n    def __len__(self):\n        return self.__len\n\n    def __setitem__(self, index, value):\n        node = self.get_node(index)\n        node.value = value\n\n    def __delitem__(self, index):\n        node = self.get_node(index)\n        if node:\n            node.prev.next = node.next\n            if node.next:\n                node.next.prev = node.prev\n            node.prev = None\n            node.next = None\n            node.value = None\n            self.__len -= 1\n\n    def __repr__(self):\n        return str(self.to_list())\n\n    def to_list(self):\n        elts = []\n        curr = self.sentinel.next\n        while curr != self.sentinel:\n            elts.append(curr.value)\n            curr = curr.next\n        return elts\n\n    def append_node(self, node):\n        self.insert_between(node, self.sentinel.prev, self.sentinel)\n\n    def append(self, value):\n        node = Node(value)\n        self.insert_between(node, self.sentinel.prev, self.sentinel)\n\n    def appendleft(self, value):\n        node = Node(value)\n        self.insert_between(node, self.sentinel, self.sentinel.next)\n\n    def insert(self, index, value):\n        new_node = Node(value)\n        len_ = len(self)\n        if len_ == 0:\n            self.insert_between(new_node, self.sentinel, self.sentinel)\n        elif index >= 0 and index < len_:\n            node = self.get_node(index)\n            self.insert_between(new_node, node.prev, node)\n        elif index == len_:\n            self.insert_between(new_node, self.sentinel.prev, self.sentinel)\n        else:\n            raise IndexError\n\n    def insert_between(self, node, left_node, right_node):\n        if node and left_node and right_node:\n            node.prev = left_node\n            node.next = right_node\n            left_node.next = node\n            right_node.prev = node\n            self.__len += 1\n        else:\n            raise IndexError\n\n    def insert_after(self, node, value):\n        new_node = Node(value)\n        node.next.prev = new_node\n        new_node.next = node.next\n        node.next = new_node\n        new_node.prev = node\n        self.__len += 1\n\n    def merge_left(self, other):\n        self.sentinel.next.prev = other.sentinel.prev\n        other.sentinel.prev.next = self.sentinel.next\n        self.sentinel.next = other.sentinel.next\n        self.sentinel.next.prev = self.sentinel\n        self.__len += other.__len\n\n    def merge_right(self, other):\n        self.sentinel.prev.next = other.sentinel.next\n        other.sentinel.next.prev = self.sentinel.prev\n        self.sentinel.prev = other.sentinel.prev\n        self.sentinel.prev.next = self.sentinel\n        self.__len += other.__len\n\n    def pop(self, node=None):\n        if node is None:\n            node = self.sentinel.prev\n        if self.__len < 1:\n            raise IndexError\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.__len -= 1\n        return node.value\n\n    def before(self, node):\n        return node.prev.prev if node.prev == self.sentinel else node.prev\n\n    left = before\n    prev = before\n\n    def after(self, node):\n        return node.next.next if node.next == self.sentinel else node.next\n\n    right = after\n    next = after\n\n\nclass Solution:\n    def maxPathScore(self, grid: List[List[int]], k: int) -> int:\n        \n\ndef main():\n    t = IO.Input.read_int()\n    for _ in range(t):\n        grid = IO.Input.read_int_2d_array()\n        k = IO.Input.read_int()\n        solution = Solution()\n        result = solution.maxPathScore(grid, k)\n        IO.output(result)\n        print()\n\n\nif __name__ == \"__main__\":\n    main()","language":"python","srcPath":"/root/codeforces/problemset/maximum_path_score_in_a_grid.py"}